<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="styles/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="scripts/header.js"></script>


    <title>Wines</title>

    <link rel="stylesheet" href="styles/site.css">

</head>

<body>
    <header id="header1" class="flexrow header">
        <div class="flexrow">
            <a href="index.html">
                <h1>
                    Project 1: Wines
                </h1>
            </a>

            <ul>
                <li>Chris C.</li>
                <li>Kristen D.</li>
                <li>Leo L.</li>
                <li>Tanisha K.</li>
            </ul>
        </div>
    </header>

    <div id="header2" class="header hidden">
        <div class="flexrow">
            <a href="index.html">
                <h1>
                    Project 2: Passwords
                </h1>
            </a>

            <ul>
                <li>Chris C.</li>
                <li>Leo L.</li>
                <li>Morris M.</li>
            </ul>
        </div>
    </div>

    <div class="flexrow" id="sourceCitation">
        <button>
            <a href="https://www.kaggle.com/datasets/zynicide/wine-reviews">
                Wine Reviews
            </a>
        </button>
        <p>
            Data sourced from <a id="zynicide" href="https://www.kaggle.com/zynicide">zynicide</a> on <a id="kaggle"
                href="https://www.kaggle.com/">kaggle</a>
        </p>
    </div>

    <main>
        <section id="sectionWine">
            <h2><em>unWINEd</em> : Visualizing the World's Wines</h2>
            <p>
                Wines are a familiar spirit to all adults, but do we really know what we're drinking? Does the country
                on
                the wine bottle's label
                matter? Can we really trust 'wine reviewers' to give us unbiased opinions?
            </p>
            <hr>
            <h3>
                Reviewers and Wine - Are the Tastebuds Biased?
            </h3>
            <p>
                Do different reviewers prefer certain countries' wines? Do those reviewers taste a variety of countries'
                wines, or do they
                tend to focus on a single country?
            </p>

            <!-- <svg id="reviewerPlot" height="600" width="900"></svg>

            <script id="chrisCodeScript">
                //Things to set
                const colors = ["green", "orange", "blue", "red", "purple"]
                const margin = { top: 10, right: 100, bottom: 150, left: 50 };
                const avgCircleR = 6;


                // Standard convenient variables
                const svg = d3.select("svg#reviewerPlot");
                const svgImg = d3.select("svg#reviewerImgs");
                const countryOffsetArray = [-20, 20];

                const width = svg.attr("width");
                const height = svg.attr("height");
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.bottom;
                let annotations = svg.append("g").attr("id", "annotations");
                let chartArea = svg.append("g").attr("id", "points")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Constructor Function
                const requestWineData = async function () {

                    // Load the data
                    var data = await d3.csv("wines.csv", d3.autoType);

                    // Filter out all data points without a taster_name, or with a taster with < 4000 reviews
                    reviewerCounts = {};
                    data.forEach((d) => {
                        if (!(d.taster_name in reviewerCounts)) {
                            reviewerCounts[d.taster_name] = 1;
                        }
                        else {
                            reviewerCounts[d.taster_name] = reviewerCounts[d.taster_name] + 1;
                        }
                    });
                    data = data.filter((d) => { return !(d.taster_name == null || (reviewerCounts[d.taster_name] < 4000)) })

                    // Let's also filter out all the wines from countries that have less than 5000 samples
                    countryCounts = {};
                    data.forEach((d) => {
                        if (!(d.country in countryCounts)) {
                            countryCounts[d.country] = 1;
                        }
                        else {
                            countryCounts[d.country] = countryCounts[d.country] + 1;
                        }
                    });
                    data = data.filter((d) => { return (countryCounts[d.country] > 5000) })

                    // Left axis (Points)
                    const pointsExtent = d3.extent(data, d => d["points"]);
                    console.log(pointsExtent);
                    const pointsScale = d3.scaleLinear().domain(pointsExtent)
                        .range([chartHeight, 0]);
                    let leftAxis = d3.axisLeft(pointsScale)
                    let leftGridlines = d3.axisLeft(pointsScale)
                        .tickSize(-chartWidth - 10)
                        .tickFormat("")
                        .ticks(pointsExtent[1] - pointsExtent[0]);
                    annotations.append("g")
                        .attr("class", "y axis")
                        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                        .call(leftAxis)
                    annotations.append("g")
                        .attr("class", "y gridlines")
                        .attr("id", "ygridline")
                        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                        .call(leftGridlines);

                    // Introduce a new variable and a function that increments it
                    // and returns a string ID value.
                    // Used to ID the gridlines, so that we can remove the lowest
                    // and top value. Also, keep track of the lowest and highest
                    // values using a simple array.
                    var lineCount = -1;
                    const lineCountExtent = [0,]
                    function incrementLineCount() {
                        lineCount = lineCount + 1;
                        lineCountExtent[1] = lineCount;
                        return ("ygridline" + lineCount);
                    }

                    // Give the gridlines an ID
                    annotations.selectAll("g#ygridline g")
                        .attr("id", d => incrementLineCount());
                    // 'Remove' the bottom and top gridlines.
                    annotations.select("g#ygridline" + lineCountExtent[0])
                        .attr("opacity", 0);
                    annotations.select("g#ygridline" + lineCountExtent[1])
                        .attr("opacity", 0);

                    // Bottom Axis (Reviewers)
                    // Make an array with all of the names for the labels
                    const labelReviewerArray = [];
                    data.forEach((d, i) => {
                        if (!labelReviewerArray.includes(d.taster_name)) {
                            labelReviewerArray.push(d.taster_name)
                        }
                    });
                    // Make another one without special characters
                    const reviewerArray = [];
                    labelReviewerArray.forEach((d) => {
                        reviewerArray.push(d.replace(/â€™/g, "").replace(/\./g, "").replace(/ /g, ""))
                    })

                    const countryArray = [];
                    data.forEach((d, i) => {
                        if (!countryArray.includes(d.country)) {
                            countryArray.push(d.country)
                        }
                    });

                    // Create a scale to map ordinal categories to the x axis
                    const reviewersScale = d3.scaleBand().domain(labelReviewerArray)
                        .range([0, chartWidth]);

                    let bottomAxis = d3.axisBottom(reviewersScale);
                    let bottomGridlines = d3.axisBottom(reviewersScale)
                        .tickSize(-chartHeight + 15)
                        .tickFormat("")

                    annotations.append("g")
                        .attr("class", "x axis")
                        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
                        .call(bottomAxis)
                        // Anna Lee C. Iijima's name is a little long, so let's just rotate all the names...
                        .selectAll("text")
                        .attr("transform", "rotate(4)")

                    annotations.append("g")
                        .attr("class", "x gridlines")
                        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top - 10) + ")")
                        .call(bottomGridlines);

                    // Put the image references in a dict for easier access
                    const imgNames = {};
                    reviewerArray.forEach((d) => {
                        imgNames[d] = ("reviewer_portraits/hedcuts/" + d + ".png");
                    });
                    // Add the reviewers' portraits
                    labelReviewerArray.forEach((d) => {
                        annotations.append("image")
                            .attr("width", 90)
                            .attr("height", 75)
                            .attr("id", d)
                            .attr("xlink:href", imgNames[d.replace(/â€™/g, "").replace(/\./g, "").replace(/ /g, "")])
                            .attr("x", (reviewersScale(d) + (reviewersScale.bandwidth() / 2) + 15))
                            .attr("y", chartHeight + 45);
                    });

                    // Now, we work on entering the points!
                    //
                    // The points tend to cluster on a single pixel, so we should somewhat randomize.
                    // I chose a normal distribution, as an equal distribution causes it to look square.
                    // The following code was found on stackOverflow, from user Maxwell Collard.
                    // https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
                    // Standard Normal variate using Box-Muller transform.
                    function gaussianRandom(mean = 0, stdev = 3) {
                        const u = 1 - Math.random(); // Converting [0,1) to (0,1]
                        const v = Math.random();
                        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                        // Transform to the desired mean and standard deviation:
                        return z * stdev + mean;
                    }

                    // Calculate colors
                    const colorScale = d3.scaleOrdinal(countryArray, colors)
                    // Offset points according to country
                    const pointAdjuster = d3.scaleBand()
                        .domain(countryArray)
                        .range(countryOffsetArray)

                    // Finally, draw the circles!
                    chartArea.selectAll("circle").data(data)
                        .join("circle")
                        .attr("class", d => (d.taster_name.replace(/â€™/g, "").replace(/\./g, "").replace(/ /g, "") + " " + d.country))
                        .attr("r", 2)
                        .attr("fill", d => colorScale(d.country))
                        .attr("opacity", 0.2)
                        // Center the circles onto the correct x-axis for the taster
                        // Then, offset them according to their country
                        // Add some normal randomness to prevent data-losing clumps
                        .attr("cx", d => reviewersScale(d.taster_name) +
                            (reviewersScale.bandwidth() / 2) +
                            (pointAdjuster(d.country) + pointAdjuster.bandwidth() / 2) + gaussianRandom(0, 7))
                        // Add some normal randomness to prevent data-losing clumps
                        .attr("cy", d => pointsScale(d.points) + gaussianRandom());

                    // Add the average circles

                    // Input: a valid taster_name
                    // Output: an array with [0] dict of the keys of country, containing the average point
                    //                       [1] dict of the countries, with values of the 
                    //                           color that the average circle's stroke should be
                    function averagesByCountry(taster) {
                        // Establish some variables
                        taster = taster.replace(/â€™/g, "").replace(/\./g, "").replace(/ /g, "");
                        result = [{}, {}]
                        let tasterData = chartArea.selectAll("circle." + taster).data();
                        let tasterCountryCounts = {};
                        let tasterCountryTotals = {};

                        // Count the number of data points for each country and add to the total
                        tasterData.forEach((d) => {
                            if (!(d.country in tasterCountryCounts)) {
                                tasterCountryCounts[d.country] = 1;
                                tasterCountryTotals[d.country] = d.points;
                                result[1][d.country] = "black";
                            }
                            else {
                                tasterCountryCounts[d.country] = tasterCountryCounts[d.country] + 1;
                                tasterCountryTotals[d.country] = tasterCountryTotals[d.country] + d.points;
                                if (tasterCountryCounts[d.country] > 1000) {
                                    result[1][d.country] = "white";
                                }
                            }
                        });

                        // 'Iterate' through the dict to calculate the averages
                        for (const [key, value] of Object.entries(tasterCountryCounts)) {
                            result[0][key] = (tasterCountryTotals[key] / tasterCountryCounts[key])
                        }

                        // Return the result
                        return result;
                    };

                    // Iterate through reviewerArray to add averages for their reviewed countries' wines.
                    labelReviewerArray.forEach((d) => {
                        let taster = d;
                        avgResult = averagesByCountry(d);
                        for (const [key, value] of Object.entries(avgResult[0])) {
                            middleX = reviewersScale(taster) +
                                (reviewersScale.bandwidth() / 2) +
                                (pointAdjuster(key) + pointAdjuster.bandwidth() / 2);
                            // I didn't end up liking adding lines
                            // chartArea.append("line")
                            //     .attr("x1", middleX - avgCircleR*3)
                            //     .attr("x2", middleX + avgCircleR*3)
                            //     .attr("y1", pointsScale(value))
                            //     .attr("y2", pointsScale(value))
                            //     .style("stroke-width", 2)
                            //     .style("stroke", (avgResult[1][key]));
                            chartArea.append("circle")
                                .attr("id", (taster.replace(/â€™/g, "").replace(/\./g, "").replace(" ", "") + key + "Average"))
                                .attr("r", avgCircleR)
                                .attr("fill", colorScale(key))
                                .style("stroke-width", 2)
                                .style("stroke", (avgResult[1][key]))
                                .attr("cx", (middleX))
                                .attr("cy", pointsScale(value))
                        }
                    });

                    // Add our legend
                    const legend = svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${chartWidth + 80}, 40)`);

                    countryArray.forEach((d, i) => {
                        legend.append("circle")
                            .attr("cx", 0)
                            .attr("cy", i * 30)
                            .attr("r", 5)
                            .style("fill", colorScale(d));

                        legend.append("text")
                            .attr("x", 10)
                            .attr("y", i * 30 + 5)
                            .text(d)
                            .style("font-size", "12px")
                            .attr("alignment-baseline", "middle");
                    });

                    legend.append("text")
                        .attr("x", 0)
                        .attr("y", -20)
                        .text("Regions")
                        .style("font-size", "14px")
                        .style("font-weight", "bold");
                };

                requestWineData();
            </script> -->

            <img src="images/wine.jpg" alt="Static Visualization of Wine Reviews by Esteemed Reviewers">

            <p id="pCredit">
                (Credit to <a
                    href="https://www.wsj.com/articles/whats-in-a-hedcut-depends-how-its-made-11576537243">WSJ</a>,
                whose hedcut model I used to create the portraits. I sourced those portraits from
                <a href="https://www.wineenthusiast.com/">WineEnthusiast.com.</a>)
            </p>

            <p>
                It looks like reviewers <em>certainly</em> tend to specialize in certain countries - namely,
                we see a lot of the top reviewers of WineEnthusiast only tasting American wines. Given that
                WineEnthusiast
                is a site based in America, maybe this is an expectable outcome.
            </p>
            <p>
                For reviewers like Roger Voss, country doesn't seem to make a large difference in his perception.
                However,
                Michael Schachner seems to dislike French varieties, while Joe Czerwinski strongly prefers them.
            </p>
        </section>

        <div id="gradient"></div>

        <section id="sectionPass">
            <div id="trigger"></div>
            <div class="full-container">
                <div class="map_bars">
                    <svg id="progress" width="700" height="160"></svg>
                    <div class="input-box" onclick="">
                        <input placeholder="Input Password" id="filter-text-val" onkeyup="" />
                    </div>
                    <div class="explanation">
                        <p>
                            On Input: Countries become colored based on what the national rank of the inputted password
                            is.
                            If the specific inputted password is not in the country's data, but some passwords
                            <em>include</em>
                            the input, the country will become grey.
                        </p>
                        <p>
                            On Hover: The selected country's passwords will be displayed. If a password has been
                            inputted,
                            all passwords including that string will be displayed.
                        </p>
                    </div>
                    <svg id="map" width="1000" height="450"></svg>
                </div>
                <div class="details_div" id="details" width="25%" height="800px"></div>
            </div>

            <script>
                // Encapsulating function
                const requestPassData = async function () {
                    // Load data
                    const data_by_country = await d3.csv("top_200_password_2020_by_country.csv");

                    // Properly type the columns
                    data_by_country.forEach((d) => {
                        d.Global_rank = parseInt(d.Global_rank);
                        d.Rank = parseInt(d.Rank);
                        d.Time_to_crack_in_seconds = parseInt(d.Time_to_crack_in_seconds);
                        d.User_count = parseInt(d.User_count);
                    });

                    // Create a dict with countries as keys for mouseovers with no input
                    // Keys: country names
                    // Value: array of length 200. Each element is itself an array with
                    // [0] the password
                    // [1] the rank
                    // [2] the user count
                    // [3] the time to crack in seconds
                    country_dict = {};
                    data_by_country.forEach((d, u) => {
                        if (d.country in country_dict) {
                            country_dict[d.country].push([data_by_country[u]["Password"],
                            data_by_country[u]["Rank"],
                            data_by_country[u]["User_count"],
                            data_by_country[u]["Time_to_crack_in_seconds"]]);
                        } else {
                            country_dict[d.country] = [[data_by_country[u]["Password"],
                            data_by_country[u]["Rank"],
                            data_by_country[u]["User_count"],
                            data_by_country[u]["Time_to_crack_in_seconds"]]];
                        }
                    });

                    // Restructure the data into a more convenient form for more general purposes
                    // The new dataframe has the following structure:
                    // data_dict = { password1 :[ {country1 : {"User_count":usercount1, "Rank":d.Rank}},
                    //                            {"Global_rank": number, "Time_to_crack_in_seconds": number}
                    //                          ],
                    //               password2: ...
                    //             }
                    // Each password is a key in the dictionary, with an array as a value.
                    // array[0] is a dict of all of the countries that have that password
                    //  Each country has a dict value with keys "User_count", "Rank"
                    // array[1] is a dict of the "Global_rank" and "Time_to_crack_in_seconds"
                    data_dict = {};
                    data_by_country.forEach((d) => {
                        if (d.Password in data_dict) {
                            data_dict[d.Password][0][d.country] = {
                                User_count: d.User_count,
                                Rank: d.Rank,
                            };
                        } else {
                            data_dict[d.Password] = [
                                { [d.country]: { User_count: d.User_count, Rank: d.Rank } },
                                {
                                    Global_rank: d.Global_rank,
                                    Time_to_crack_in_seconds: d.Time_to_crack_in_seconds,
                                },
                            ];
                        }
                    });

                    // Make an array containing all of the passwords
                    var passwords = Object.keys(data_dict);

                    // Create a sorted array based on the global_rank
                    // Used to display the passwords in order
                    var sorted_passwords = [];
                    passwords.forEach(d => {
                        if (!sorted_passwords.includes(d) && !isNaN(data_dict[d][1]["Global_rank"])) {
                            sorted_passwords.push(d);
                        };
                    });
                    sorted_passwords.sort((a, b) => {
                        let a_rank = data_dict[a][1]["Global_rank"];
                        let b_rank = data_dict[b][1]["Global_rank"];

                        return a_rank - b_rank;
                    });

                    // Push the rest of the passwords onto the end.
                    passwords.forEach(d => {
                        if (!sorted_passwords.includes(d)) {
                            sorted_passwords.push(d);
                        };
                    });


                    //--- Beginning of Map stuff
                    // Declaring selectors
                    const svg = d3.select(map);
                    const progress = d3.select("#progress");
                    const width = svg.attr("width");
                    const height = svg.attr("height");
                    const detail_box = d3.select("div#details");
                    const input = d3.select("input#filter-text-val");
                    var input_text = "";

                    // Linear scale from 1 to 200, since only top 200 passwords are
                    // included in the dataset
                    const colorScale = d3
                        .scaleQuantize()
                        .domain([1, 200])
                        .range(["#001b75", "#003a5a", "#004d5f", "#005f66", "#016f6c", "#027f6f", "#038f6c", "#059f5f", "#07b114"].reverse());

                    // Load a global world map
                    const globe = await d3.json("./countries-50m.json");
                    const removedCountries = [
                        "Fr. S. Antarctic Lands",
                        "Antarctica",
                        "Fr. Polynesia",
                        "American Samoa",
                        "Micronesia",
                        "Marshall Is.",
                    ];

                    //remove unwanted regions
                    globe.objects.countries.geometries =
                        globe.objects.countries.geometries.filter(
                            (d) => !removedCountries.includes(d.properties.name)
                        );

                    var countries = topojson.feature(globe, globe.objects.countries);
                    var countriesMesh = topojson.mesh(globe, globe.objects.countries);

                    //using a globe projection for the map
                    var projection = d3
                        .geoNaturalEarth1()
                        .fitSize([width, height], countries);
                    var path = d3.geoPath().projection(projection);

                    let viewport = svg.append("g");

                    //draw country areas
                    viewport
                        .selectAll("path.country")
                        .data(countries.features)
                        .join("path")
                        .attr("class", "country")
                        .attr("id", (d) => d.properties.name.replace(/\s/g, ""))
                        .attr("d", path)
                        .style("fill", "black")
                        .on("mouseover", mouseEntersState)
                        .on("mouseout", mouseLeavesState);

                    //draw country borders
                    viewport
                        .append("path")
                        .datum(countriesMesh)
                        .attr("class", "outline")
                        .attr("fill", "none")
                        .attr("stroke", "white")
                        .attr("d", path);

                    //used for border mous
                    let momesh = viewport
                        .append("path")
                        .attr("class", "mouseover outline")
                        .style("stroke", "white")
                        .style("stroke-width", 3)
                        .attr("fill", "none")
                        .attr("d", "");

                    // beginning of legend functionality
                    var legend = d3
                        .legendColor()
                        .scale(colorScale)
                        .title("Color - Rank")
                        .labelFormat(d3.format(".0f"));

                    svg
                        .append("rect")
                        .attr("id", "legend_container")
                        .attr("x", 50)
                        .attr("y", 220)
                        .attr("width", 125)
                        .attr("height", 210);

                    svg
                        .append("g")
                        .attr("transform", "translate(70,240)")
                        .attr("font-weight", "Bold")
                        .attr("font-size", "10")
                        .call(legend);

                    //END OF MAP STUFF----------

                    let progress_text1 = progress
                        .append("text")
                        .text("Average Crack Time for a ?-Character Password:")
                        .attr("x", 20)
                        .attr("y", 20);

                    progress
                        .append("rect")
                        .attr("class", "bar_container")
                        .attr("x", 20)
                        .attr("y", 30)
                        .attr("width", 660)
                        .attr("height", 17);

                    const progress_bar1 = progress
                        .append("rect")
                        .attr("id", "progress_bar1")
                        .attr("x", 20)
                        .attr("y", 30)
                        .attr("width", 0)
                        .attr("height", 17)
                        .attr("fill", "#66FF66");

                    let chevron1 = progress
                        .append("polygon")
                        .attr("points", "20, 48 15, 58 25, 58")
                        .attr("fill", "white");

                    let crack_time1 = progress
                        .append("text")
                        .text("N/A")
                        .attr("x", 20)
                        .attr("y", 72);

                    progress
                        .append("text")
                        .text("Average Crack Time for Input Password:")
                        .attr("x", 20)
                        .attr("y", 100);

                    progress
                        .append("rect")
                        .attr("class", "bar_container")
                        .attr("x", 20)
                        .attr("y", 110)
                        .attr("width", 660)
                        .attr("height", 17);

                    const progress_bar2 = progress
                        .append("rect")
                        .attr("id", "crack_time_progress")
                        .attr("x", 20)
                        .attr("y", 110)
                        .attr("width", 0)
                        .attr("height", 17)
                        .attr("fill", "#00FFFF");

                    let chevron2 = progress
                        .append("polygon")
                        .attr("points", "20, 128 15, 138 25, 138")
                        .attr("fill", "white");

                    let crack_time2 = progress
                        .append("text")
                        .text("N/A")
                        .attr("x", 20)
                        .attr("y", 152);

                    function update_progress(password) {
                        // Reset the progress bars every time we start
                        progress_bar2.interrupt().attr("width", 0);
                        progress_bar1.interrupt().attr("width", 0);
                        chevron1.interrupt().attr("points", "20, 48 15, 58 25, 58");
                        chevron2.interrupt().attr("points", "20, 128 15, 138 25, 138");

                        // Change the text to reflect the length of the input
                        passCrackTime = Math.round(
                            (Math.pow(62, password.length) / Math.pow(10, 9)) * 1000
                        );
                        progress_text1.text(
                            `Average Crack Time for a ${password.length}-Character Password:`
                        );

                        // Add the crack time bar that's based on the input's length
                        // Not based on whether or not it's in the dataset
                        crack_time1.text(secondsToHms(passCrackTime));
                        progress_bar1
                            .transition()
                            .duration(Math.max(passCrackTime * 1000, 100))
                            .ease(d3.easeLinear)
                            .attr("width", 660);

                        chevron1
                            .transition()
                            .duration(Math.max(passCrackTime * 1000, 100))
                            .ease(d3.easeLinear)
                            .attr("points", "680, 48 675, 58 685, 58");

                        // If the input isn't in the dataset, then don't make the next bar
                        if (data_dict[password] === undefined) {
                            crack_time2.text("Input Password Not In Dataset");
                            progress_bar2.attr("width", 0);
                            return;
                        }

                        const average_crack_time =
                            data_dict[password][1]["Time_to_crack_in_seconds"];
                        crack_time2.text(secondsToHms(average_crack_time));
                        progress_bar2
                            .transition()
                            .duration(Math.max(100, average_crack_time * 1000))
                            .ease(d3.easeLinear)
                            .attr("width", 660);
                        chevron2
                            .transition()
                            .duration(Math.max(100, average_crack_time * 1000))
                            .ease(d3.easeLinear)
                            .attr("points", "680, 128 675, 138 685, 138");
                    }

                    // Reset the countryPassDict to be empty
                    // This dict contains the passwords that include the input string,
                    // with the values as a dict of countries that have the password data
                    // for each country, their value is an array.
                    // [0] is the national rank, [1] is the user_count
                    // i.e., if you type in "abc":
                    // {"abcdef": {"Czechia", [12, 12414],
                    //             "Canada", [1, 11124141] }
                    //  "abcddd": {"Czechia", [51, 141]}
                    countryPassDict = {};

                    function updateMap(input) {
                        // Populate an array with all of the passwords that include the input
                        included_passwords = [];
                        sorted_passwords.forEach((d) => {
                            if (d.includes(input)) {
                                included_passwords.push(d);
                            }
                        });

                        // Iterate through each password that includes the string
                        included_passwords.forEach((pw) => {
                            // Iterate through each country that has data for that password
                            Object.keys(data_dict[pw][0]).forEach((country) => {
                                // If it's not new, add to the existing dict of strings
                                if (
                                    countryPassDict[countryMatch(country, countryMatchDict)] != null
                                ) {
                                    countryPassDict[countryMatch(country, countryMatchDict)][pw] = [
                                        data_dict[pw][0][country]["Rank"],
                                        data_dict[pw][0][country]["User_count"],
                                    ];
                                    // If it is new, then we add a dict with the keys as passwords with a value of an array
                                    // [0] is the rank, [1] is the user_count
                                } else {
                                    countryPassDict[countryMatch(country, countryMatchDict)] = {
                                        [pw]: [
                                            data_dict[pw][0][country]["Rank"],
                                            data_dict[pw][0][country]["User_count"],
                                        ],
                                    };
                                }
                            });
                        });
                    }

                    // Some countries are worded differently - we keep a log of them here
                    countryMatchDict = {
                        UnitedKingdom: "United Kingdom",
                        CzechRepublic: "Czechia",
                        Korea: "SouthKorea",
                        UnitedStates: "UnitedStatesofAmerica",
                        SouthAfrica: "South Africa",
                        NewZealand: "New Zealand",
                        UnitedArabEmirates: "United Arab Emirates",
                        SaudiArabia: "Saudi Arabia"
                    };

                    reverseCountryMatchDict = {
                        UnitedKingdom: "United Kingdom",
                        UnitedStatesofAmerica: "United States",
                        SouthAfrica: "South Africa",
                        SouthKorea: "South Korea",
                        NorthKorea: "North Korea",
                        NewZealand: "New Zealand",
                        Czechia: "Czech Republic",
                        UnitedArabEmirates: "United Arab Emirates",
                        SaudiArabia: "Saudi Arabia"
                    };

                    // We use this function to go from the countryMatchDict key to the value
                    function countryMatch(input, dict) {
                        if (input in dict) {
                            return dict[input];
                        } else {
                            return input;
                        }
                    }

                    // Credit: https://stackoverflow.com/a/37096512
                    // Input: a number (or string) of seconds
                    // Output: a string that represents the hours, minutes, and seconds of that number
                    function secondsToHms(d) {
                        if (d < 1) {
                            return "<1 Second";
                        };

                        d = Number(d);
                        var year = Math.floor(d / 31536000)
                        var day = Math.floor(d % 31536000 / 86400);
                        var h = Math.floor((d % 86400) / 3600);
                        var m = Math.floor((d % 3600) / 60);
                        var s = Math.floor(d % 60);

                        var yearDisplay = year > 0 ? year + (year == 1 ? " Year, " : " Years, ") : "";
                        var dayDisplay = day > 0 ? day + (((s != 0) && (m != 0) && (h != 0)) ? (day == 1 ? " Day, " : " Days, ") : (day == 1 ? " Day " : " Days ")) : "";
                        var hDisplay = h > 0 ? h + (((s != 0) && (m != 0)) ? (h == 1 ? " Hour, " : " Hours, ") : (h == 1 ? " Hour " : " Hours ")) : "";
                        var mDisplay = m > 0 ? m + ((s != 0 ? (m == 1 ? " Minute, " : " Minutes, ") : (m == 1 ? " Minute " : " Minutes "))) : "";
                        var sDisplay = s > 0 ? s + (s == 1 ? " Second" : " Seconds") : "";
                        return yearDisplay + dayDisplay + hDisplay + mDisplay + sDisplay;
                    }

                    function updateColor(input, dict) {
                        //update the colors of the map using dict rank values
                        viewport.selectAll(".country").style("fill", (d) => {
                            if (input === "") { return "black"; }

                            let countryName = d.properties.name;

                            //edge cases
                            if (countryName === "United States of America")
                                countryName = "United States";
                            if (countryName === "Czechia") countryName = "Czech Republic";

                            if (dict[countryName] != null) {
                                if (dict[countryName][input] != null) {
                                    //return color based on rank color scale
                                    return colorScale(dict[countryName][input][0]);
                                }
                                //return if password is substring of another
                                return "#615e5e";
                            }
                            // no data (return default color)
                            return "black";
                        });
                    }

                    function mouseEntersState() {
                        // Clear the detail box
                        detail_box.selectAll("*").remove();
                        let country = d3.select(this);
                        let country_name = country.attr("id");
                        let country_name_matched = countryMatch(country_name, reverseCountryMatchDict);

                        //change mesh path width on mousover
                        var mo = topojson.mesh(
                            globe,
                            globe.objects.countries,
                            function (a, b) {
                                return a.id === country.datum().id || b.id === country.datum().id;
                            }
                        );
                        momesh.datum(mo).attr("d", path);

                        // Change the header of the detail box to the country's name
                        detail_box.append("h3")
                            .text(country_name_matched);

                        // If no input is given but a country is moused over,
                        // Display every password in the country

                        if (country_name_matched in country_dict) {
                            if (input_text === "") {
                                country_dict[country_name_matched].forEach(d => {
                                    let country_ul = detail_box
                                        .append("ul")
                                        .text(`"${d[0]}", Rank: ${d[1]}`);
                                    country_ul
                                        .append("li")
                                        .text(`${d[2].toLocaleString()} Users`)
                                    country_ul
                                        .append("li")
                                        .text(`Time to crack: ${secondsToHms(d[3])}`)
                                });
                            }
                            // Display the selected country's passwords if there is an input
                            // `<ul>` is the password
                            // `<li>` are the ranks and user counts
                            else {
                                // Make sure we have data for the country
                                if (
                                    country_name_matched in
                                    countryPassDict
                                ) {
                                    // Iterate through the arrays in countryPassDict's value for the country
                                    Object.keys(
                                        countryPassDict[
                                        country_name_matched
                                        ]
                                    ).forEach((d) => {
                                        // Create a `<ul>`
                                        let country_ul = detail_box
                                            .append("ul")
                                            .text(
                                                `"${d}", Rank: ${countryPassDict[
                                                country_name_matched
                                                ][d][0]
                                                }`
                                            );
                                        country_ul
                                            .append("li")
                                            .text(
                                                `${countryPassDict[
                                                    country_name_matched
                                                ][d][1].toLocaleString()} Users`
                                            );
                                        country_ul
                                            .append("li")
                                            .text(`Time to crack: ${secondsToHms(data_dict[d][1]["Time_to_crack_in_seconds"])}`);
                                    });
                                }
                            }
                            // If the country is not in the dataset
                        } else {
                            detail_box.append("p")
                                .text("Country not in dataset.");
                        }
                    }


                    // Reset the country path
                    function mouseLeavesState() {
                        let country = d3.select(this);
                        momesh.attr("d", "");
                    }

                    // Creates the initial detail box when page is loaded
                    // Every password in the data set is displayed
                    function defaultDetailMaker() {
                        detail_box.selectAll("*").remove();
                        detail_box.append("h3")
                            .text("Passwords in Dataset:");
                        sorted_passwords.forEach(d => {
                            rank = data_dict[d][1]["Global_rank"];
                            time = data_dict[d][1]["Time_to_crack_in_seconds"];

                            let pass_ul = detail_box.append("ul")
                                .text(`"${d}"`);
                            if (!isNaN(rank)) {
                                pass_ul.append("li")
                                    .text(`Global rank: ${rank}`);
                            }
                            pass_ul.append("li")
                                .text(`Time to crack: ${secondsToHms(time)}`);
                        })
                    }

                    defaultDetailMaker();

                    // When things are inputted into the `<input>`
                    // Reset the dictionary of countries and passwords
                    // Update the map
                    // Update the progress bars
                    input.on("input", function () {
                        input_text = input.node().value;
                        detail_box.selectAll("*").remove();

                        if (input_text != "") {
                            detail_box.append("h3")
                                .text(`Passwords including "${input_text}":`);

                            sorted_passwords.forEach((d) => {
                                rank = data_dict[d][1]["Global_rank"];
                                time = data_dict[d][1]["Time_to_crack_in_seconds"];


                                if (d.includes(input_text)) {
                                    let pass_ul = detail_box.append("ul")
                                        .text(`"${d}"`);
                                    if (!isNaN(rank)) {
                                        pass_ul.append("li")
                                            .text(`Global rank: ${rank}`);
                                    }
                                    pass_ul.append("li")
                                        .text(`Time to crack: ${secondsToHms(time)}`);
                                }
                            });
                        } else {
                            defaultDetailMaker();
                        }

                        countryPassDict = {};
                        updateMap(input_text);
                        update_progress(input_text);
                        updateColor(input_text, countryPassDict);
                    });
                };

                requestPassData();
            </script>
        </section>
    </main>

    <footer>

    </footer>
</body>

</html>