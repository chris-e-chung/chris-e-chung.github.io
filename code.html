<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>P2</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet" />
</head>

<body>
  <div class="full-container">
    <div class="map_bars">
      <svg id="progress" width="700" height="160"></svg>
      <div class="input-box" onclick="">
        <input placeholder="Input Password" id="filter-text-val" onkeyup="" />
      </div>
      <div class="explanation">
        <p>
          On Input: Countries become colored based on what the national rank of the inputted password is.
                    If the specific inputted password is not in the country's data, but some passwords <em>include</em>
                    the input, the country will become grey.
        </p>
        <p>
          On Hover: The selected country's passwords will be displayed. If a password has been inputted,
                    all passwords including that string will be displayed.
        </p>
      </div>
      <svg id="map" width="1000" height="450"></svg>
    </div>
    <div class="details_div" id="details" width="25%" height="800px"></div>
  </div>

  <script>
    // Encapsulating function
    const requestData = async function () {
      // Load data
      const data_by_country = await d3.csv("top_200_password_2020_by_country.csv");

      // Properly type the columns
      data_by_country.forEach((d) => {
        d.Global_rank = parseInt(d.Global_rank);
        d.Rank = parseInt(d.Rank);
        d.Time_to_crack_in_seconds = parseInt(d.Time_to_crack_in_seconds);
        d.User_count = parseInt(d.User_count);
      });

      // Create a dict with countries as keys for mouseovers with no input
      // Keys: country names
      // Value: array of length 200. Each element is itself an array with
      // [0] the password
      // [1] the rank
      // [2] the user count
      // [3] the time to crack in seconds
      country_dict = {};
      data_by_country.forEach((d, u) => {
        if (d.country in country_dict) {
          country_dict[d.country].push([data_by_country[u]["Password"],
          data_by_country[u]["Rank"],
          data_by_country[u]["User_count"],
          data_by_country[u]["Time_to_crack_in_seconds"]]);
        } else {
          country_dict[d.country] = [[data_by_country[u]["Password"],
          data_by_country[u]["Rank"],
          data_by_country[u]["User_count"],
          data_by_country[u]["Time_to_crack_in_seconds"]]];
        }
      });

      // Restructure the data into a more convenient form for more general purposes
      // The new dataframe has the following structure:
      // data_dict = { password1 :[ {country1 : {"User_count":usercount1, "Rank":d.Rank}},
      //                            {"Global_rank": number, "Time_to_crack_in_seconds": number}
      //                          ],
      //               password2: ...
      //             }
      // Each password is a key in the dictionary, with an array as a value.
      // array[0] is a dict of all of the countries that have that password
      //  Each country has a dict value with keys "User_count", "Rank"
      // array[1] is a dict of the "Global_rank" and "Time_to_crack_in_seconds"
      data_dict = {};
      data_by_country.forEach((d) => {
        if (d.Password in data_dict) {
          data_dict[d.Password][0][d.country] = {
            User_count: d.User_count,
            Rank: d.Rank,
          };
        } else {
          data_dict[d.Password] = [
            { [d.country]: { User_count: d.User_count, Rank: d.Rank } },
            {
              Global_rank: d.Global_rank,
              Time_to_crack_in_seconds: d.Time_to_crack_in_seconds,
            },
          ];
        }
      });

      // Make an array containing all of the passwords
      var passwords = Object.keys(data_dict);

      // Create a sorted array based on the global_rank
      // Used to display the passwords in order
      var sorted_passwords = [];
      passwords.forEach(d => {
        if (!sorted_passwords.includes(d) && !isNaN(data_dict[d][1]["Global_rank"])) {
          sorted_passwords.push(d);
        };
      });
      sorted_passwords.sort((a, b) => {
        let a_rank = data_dict[a][1]["Global_rank"];
        let b_rank = data_dict[b][1]["Global_rank"];

        return a_rank - b_rank;
      });

      // Push the rest of the passwords onto the end.
      passwords.forEach(d => {
        if (!sorted_passwords.includes(d)) {
          sorted_passwords.push(d);
        };
      });


      //--- Beginning of Map stuff
      // Declaring selectors
      const svg = d3.select(map);
      const progress = d3.select("#progress");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const detail_box = d3.select("div#details");
      const input = d3.select("input#filter-text-val");
      var input_text = "";

      // Linear scale from 1 to 200, since only top 200 passwords are
      // included in the dataset
      const colorScale = d3
        .scaleQuantize()
        .domain([1, 200])
        .range(["#001b75", "#003a5a", "#004d5f", "#005f66", "#016f6c", "#027f6f", "#038f6c", "#059f5f", "#07b114"].reverse());

      // Load a global world map
      const globe = await d3.json("./countries-50m.json");
      const removedCountries = [
        "Fr. S. Antarctic Lands",
        "Antarctica",
        "Fr. Polynesia",
        "American Samoa",
        "Micronesia",
        "Marshall Is.",
      ];

      //remove unwanted regions
      globe.objects.countries.geometries =
        globe.objects.countries.geometries.filter(
          (d) => !removedCountries.includes(d.properties.name)
        );

      var countries = topojson.feature(globe, globe.objects.countries);
      var countriesMesh = topojson.mesh(globe, globe.objects.countries);

      //using a globe projection for the map
      var projection = d3
        .geoNaturalEarth1()
        .fitSize([width, height], countries);
      var path = d3.geoPath().projection(projection);

      let viewport = svg.append("g");

      //draw country areas
      viewport
        .selectAll("path.country")
        .data(countries.features)
        .join("path")
        .attr("class", "country")
        .attr("id", (d) => d.properties.name.replace(/\s/g, ""))
        .attr("d", path)
        .style("fill", "black")
        .on("mouseover", mouseEntersState)
        .on("mouseout", mouseLeavesState);

      //draw country borders
      viewport
        .append("path")
        .datum(countriesMesh)
        .attr("class", "outline")
        .attr("fill", "none")
        .attr("stroke", "white")
        .attr("d", path);

      //used for border mous
      let momesh = viewport
        .append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "white")
        .style("stroke-width", 3)
        .attr("fill", "none")
        .attr("d", "");

      // beginning of the zoom functionality
      var zoom = d3
        .zoom()
        .scaleExtent([1, 20])
        .translateExtent([
          [0, 0],
          [width, height],
        ])
        .on("zoom", mapZoomed);

      svg.call(zoom);
      svg.call(zoom.transform, d3.zoomIdentity);

      function mapZoomed({ transform }) {
        viewport.attr("transform", transform.toString());
        viewport.select("outline").style("stroke-width", 1 / transform.k);
      }

      // beginning of legend functionality
      var legend = d3
        .legendColor()
        .scale(colorScale)
        .title("Color - Rank")
        .labelFormat(d3.format(".0f"));

      svg
        .append("rect")
        .attr("id", "legend_container")
        .attr("x", 50)
        .attr("y", 220)
        .attr("width", 125)
        .attr("height", 210);

      svg
        .append("g")
        .attr("transform", "translate(70,240)")
        .attr("font-weight", "Bold")
        .attr("font-size", "10")
        .call(legend);

      //END OF MAP STUFF----------

      let progress_text1 = progress
        .append("text")
        .text("Average Crack Time for a ?-Character Password:")
        .attr("x", 20)
        .attr("y", 20);

      progress
        .append("rect")
        .attr("class", "bar_container")
        .attr("x", 20)
        .attr("y", 30)
        .attr("width", 660)
        .attr("height", 17);

      const progress_bar1 = progress
        .append("rect")
        .attr("id", "progress_bar1")
        .attr("x", 20)
        .attr("y", 30)
        .attr("width", 0)
        .attr("height", 17)
        .attr("fill", "#66FF66");

      let chevron1 = progress
        .append("polygon")
        .attr("points", "20, 48 15, 58 25, 58")
        .attr("fill", "white");

      let crack_time1 = progress
        .append("text")
        .text("N/A")
        .attr("x", 20)
        .attr("y", 72);

      progress
        .append("text")
        .text("Average Crack Time for Input Password:")
        .attr("x", 20)
        .attr("y", 100);

      progress
        .append("rect")
        .attr("class", "bar_container")
        .attr("x", 20)
        .attr("y", 110)
        .attr("width", 660)
        .attr("height", 17);

      const progress_bar2 = progress
        .append("rect")
        .attr("id", "crack_time_progress")
        .attr("x", 20)
        .attr("y", 110)
        .attr("width", 0)
        .attr("height", 17)
        .attr("fill", "#00FFFF");

      let chevron2 = progress
        .append("polygon")
        .attr("points", "20, 128 15, 138 25, 138")
        .attr("fill", "white");

      let crack_time2 = progress
        .append("text")
        .text("N/A")
        .attr("x", 20)
        .attr("y", 152);

      function update_progress(password) {
        // Reset the progress bars every time we start
        progress_bar2.interrupt().attr("width", 0);
        progress_bar1.interrupt().attr("width", 0);
        chevron1.interrupt().attr("points", "20, 48 15, 58 25, 58");
        chevron2.interrupt().attr("points", "20, 128 15, 138 25, 138");

        // Change the text to reflect the length of the input
        passCrackTime = Math.round(
          (Math.pow(62, password.length) / Math.pow(10, 9)) * 1000
        );
        progress_text1.text(
          `Average Crack Time for a ${password.length}-Character Password:`
        );

        // Add the crack time bar that's based on the input's length
        // Not based on whether or not it's in the dataset
        crack_time1.text(secondsToHms(passCrackTime));
        progress_bar1
          .transition()
          .duration(Math.max(passCrackTime * 1000, 100))
          .ease(d3.easeLinear)
          .attr("width", 660);

        chevron1
          .transition()
          .duration(Math.max(passCrackTime * 1000, 100))
          .ease(d3.easeLinear)
          .attr("points", "680, 48 675, 58 685, 58");

        // If the input isn't in the dataset, then don't make the next bar
        if (data_dict[password] === undefined) {
          crack_time2.text("Input Password Not In Dataset");
          progress_bar2.attr("width", 0);
          return;
        }

        const average_crack_time =
          data_dict[password][1]["Time_to_crack_in_seconds"];
        crack_time2.text(secondsToHms(average_crack_time));
        progress_bar2
          .transition()
          .duration(Math.max(100, average_crack_time * 1000))
          .ease(d3.easeLinear)
          .attr("width", 660);
        chevron2
          .transition()
          .duration(Math.max(100, average_crack_time * 1000))
          .ease(d3.easeLinear)
          .attr("points", "680, 128 675, 138 685, 138");
      }

      // Reset the countryPassDict to be empty
      // This dict contains the passwords that include the input string,
      // with the values as a dict of countries that have the password data
      // for each country, their value is an array.
      // [0] is the national rank, [1] is the user_count
      // i.e., if you type in "abc":
      // {"abcdef": {"Czechia", [12, 12414],
      //             "Canada", [1, 11124141] }
      //  "abcddd": {"Czechia", [51, 141]}
      countryPassDict = {};

      function updateMap(input) {
        // Populate an array with all of the passwords that include the input
        included_passwords = [];
        sorted_passwords.forEach((d) => {
          if (d.includes(input)) {
            included_passwords.push(d);
          }
        });

        // Iterate through each password that includes the string
        included_passwords.forEach((pw) => {
          // Iterate through each country that has data for that password
          Object.keys(data_dict[pw][0]).forEach((country) => {
            // If it's not new, add to the existing dict of strings
            if (
              countryPassDict[countryMatch(country, countryMatchDict)] != null
            ) {
              countryPassDict[countryMatch(country, countryMatchDict)][pw] = [
                data_dict[pw][0][country]["Rank"],
                data_dict[pw][0][country]["User_count"],
              ];
              // If it is new, then we add a dict with the keys as passwords with a value of an array
              // [0] is the rank, [1] is the user_count
            } else {
              countryPassDict[countryMatch(country, countryMatchDict)] = {
                [pw]: [
                  data_dict[pw][0][country]["Rank"],
                  data_dict[pw][0][country]["User_count"],
                ],
              };
            }
          });
        });
      }

      // Some countries are worded differently - we keep a log of them here
      countryMatchDict = {
        UnitedKingdom: "United Kingdom",
        CzechRepublic: "Czechia",
        Korea: "SouthKorea",
        UnitedStates: "UnitedStatesofAmerica",
        SouthAfrica: "South Africa",
        NewZealand: "New Zealand",
        UnitedArabEmirates: "United Arab Emirates",
        SaudiArabia: "Saudi Arabia"
      };

      reverseCountryMatchDict = {
        UnitedKingdom: "United Kingdom",
        UnitedStatesofAmerica: "United States",
        SouthAfrica: "South Africa",
        SouthKorea: "South Korea",
        NorthKorea: "North Korea",
        NewZealand: "New Zealand",
        Czechia: "Czech Republic",
        UnitedArabEmirates: "United Arab Emirates",
        SaudiArabia: "Saudi Arabia"
      };

      // We use this function to go from the countryMatchDict key to the value
      function countryMatch(input, dict) {
        if (input in dict) {
          return dict[input];
        } else {
          return input;
        }
      }

      // Credit: https://stackoverflow.com/a/37096512
      // Input: a number (or string) of seconds
      // Output: a string that represents the hours, minutes, and seconds of that number
      function secondsToHms(d) {
        if (d < 1) {
          return "<1 Second";
        };

        d = Number(d);
        var year = Math.floor(d / 31536000)
        var day = Math.floor(d % 31536000 / 86400);
        var h = Math.floor((d % 86400) / 3600);
        var m = Math.floor((d % 3600) / 60);
        var s = Math.floor(d % 60);

        var yearDisplay = year > 0 ? year + (year == 1 ? " Year, " : " Years, ") : "";
        var dayDisplay = day > 0 ? day + (((s != 0) && (m != 0) && (h != 0)) ? (day == 1 ? " Day, " : " Days, ") : (day == 1 ? " Day " : " Days ")) : "";
        var hDisplay = h > 0 ? h + (((s != 0) && (m != 0)) ? (h == 1 ? " Hour, " : " Hours, ") : (h == 1 ? " Hour " : " Hours ")) : "";
        var mDisplay = m > 0 ? m + ((s != 0 ? (m == 1 ? " Minute, " : " Minutes, ") : (m == 1 ? " Minute " : " Minutes "))) : "";
        var sDisplay = s > 0 ? s + (s == 1 ? " Second" : " Seconds") : "";
        return yearDisplay + dayDisplay + hDisplay + mDisplay + sDisplay;
      }

      function updateColor(input, dict) {
        //update the colors of the map using dict rank values
        viewport.selectAll(".country").style("fill", (d) => {
          if (input === "") { return "black"; }

          let countryName = d.properties.name;

          //edge cases
          if (countryName === "United States of America")
            countryName = "United States";
          if (countryName === "Czechia") countryName = "Czech Republic";

          if (dict[countryName] != null) {
            if (dict[countryName][input] != null) {
              //return color based on rank color scale
              return colorScale(dict[countryName][input][0]);
            }
            //return if password is substring of another
            return "#615e5e";
          }
          // no data (return default color)
          return "black";
        });
      }

      function mouseEntersState() {
        // Clear the detail box
        detail_box.selectAll("*").remove();
        let country = d3.select(this);
        let country_name = country.attr("id");
        let country_name_matched = countryMatch(country_name, reverseCountryMatchDict);

        //change mesh path width on mousover
        var mo = topojson.mesh(
          globe,
          globe.objects.countries,
          function (a, b) {
            return a.id === country.datum().id || b.id === country.datum().id;
          }
        );
        momesh.datum(mo).attr("d", path);

        // Change the header of the detail box to the country's name
        detail_box.append("h3")
          .text(country_name_matched);

        // If no input is given but a country is moused over,
        // Display every password in the country

        if (country_name_matched in country_dict) {
          if (input_text === "") {
            country_dict[country_name_matched].forEach(d => {
              let country_ul = detail_box
                .append("ul")
                .text(`"${d[0]}", Rank: ${d[1]}`);
              country_ul
                .append("li")
                .text(`${d[2].toLocaleString()} Users`)
              country_ul
                .append("li")
                .text(`Time to crack: ${secondsToHms(d[3])}`)
            });
          }
          // Display the selected country's passwords if there is an input
          // `<ul>` is the password
          // `<li>` are the ranks and user counts
          else {
            // Make sure we have data for the country
            if (
              country_name_matched in
              countryPassDict
            ) {
              // Iterate through the arrays in countryPassDict's value for the country
              Object.keys(
                countryPassDict[
                country_name_matched
                ]
              ).forEach((d) => {
                // Create a `<ul>`
                let country_ul = detail_box
                  .append("ul")
                  .text(
                    `"${d}", Rank: ${countryPassDict[
                    country_name_matched
                    ][d][0]
                    }`
                  );
                country_ul
                  .append("li")
                  .text(
                    `${countryPassDict[
                      country_name_matched
                    ][d][1].toLocaleString()} Users`
                  );
                country_ul
                  .append("li")
                  .text(`Time to crack: ${secondsToHms(data_dict[d][1]["Time_to_crack_in_seconds"])}`);
              });
            }
          }
          // If the country is not in the dataset
        } else {
          detail_box.append("p")
            .text("Country not in dataset.");
        }
      }


      // Reset the country path
      function mouseLeavesState() {
        let country = d3.select(this);
        momesh.attr("d", "");
      }

      // Creates the initial detail box when page is loaded
      // Every password in the data set is displayed
      function defaultDetailMaker() {
        detail_box.selectAll("*").remove();
        detail_box.append("h3")
          .text("Passwords in Dataset:");
        sorted_passwords.forEach(d => {
          rank = data_dict[d][1]["Global_rank"];
          time = data_dict[d][1]["Time_to_crack_in_seconds"];

          let pass_ul = detail_box.append("ul")
            .text(`"${d}"`);
          if (!isNaN(rank)) {
            pass_ul.append("li")
              .text(`Global rank: ${rank}`);
          }
          pass_ul.append("li")
            .text(`Time to crack: ${secondsToHms(time)}`);
        })
      }

      defaultDetailMaker();

      // When things are inputted into the `<input>`
      // Reset the dictionary of countries and passwords
      // Update the map
      // Update the progress bars
      input.on("input", function () {
        input_text = input.node().value;
        detail_box.selectAll("*").remove();

        if (input_text != "") {
          detail_box.append("h3")
            .text(`Passwords including "${input_text}":`);

          sorted_passwords.forEach((d) => {
            rank = data_dict[d][1]["Global_rank"];
            time = data_dict[d][1]["Time_to_crack_in_seconds"];


            if (d.includes(input_text)) {
              let pass_ul = detail_box.append("ul")
                .text(`"${d}"`);
              if (!isNaN(rank)) {
                pass_ul.append("li")
                  .text(`Global rank: ${rank}`);
              }
              pass_ul.append("li")
                .text(`Time to crack: ${secondsToHms(time)}`);
            }
          });
        } else {
          defaultDetailMaker();
        }

        countryPassDict = {};
        updateMap(input_text);
        update_progress(input_text);
        updateColor(input_text, countryPassDict);
      });
    };

    requestData();
  </script>
</body>

</html>